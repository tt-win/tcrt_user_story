app:
  database_url: sqlite:///./test_case_repo.db
  debug: false
  host: 0.0.0.0
  port: 9999
jira:
  api_token: 'YOUR_JIRA_API_TOKEN'
  server_url: 'https://your-domain.atlassian.net'
  username: 'your-username'
  ca_cert_path: ''
lark:
  app_id: 'YOUR_LARK_APP_ID'
  app_secret: 'YOUR_LARK_APP_SECRET'
openrouter:
  api_key: 'YOUR_OPENROUTER_API_KEY'
  model: 'openai/gpt-oss-120b:free'
ai:
  jira_testcase_helper:
    similar_cases_count: 5
    similar_cases_max_length: 500
    enable_ir_first: true
    coverage_backfill_max_rounds: 1
    coverage_backfill_chunk_size: 12
    coverage_force_complete: true
    testcase_force_complete: true
    min_steps: 3
    api_min_steps: 2
    min_preconditions: 1
    max_vi_per_section: 12
    max_repair_rounds: 3
    forbidden_patterns:
      - '參考'
      - 'REF\d+'
      - '同上'
      - '略'
      - 'TBD'
      - 'N/A'
      - '待補'
      - 'TODO'
    models:
      analysis:
        model: 'google/gemini-3-flash-preview'
        api_url: 'https://openrouter.ai/api/v1/chat/completions'
        temperature: 0.1
        timeout: 120
        system_prompt: 'You are a senior QA analyst.'
      coverage:
        model: 'openai/gpt-5.2'
        api_url: 'https://openrouter.ai/api/v1/chat/completions'
        temperature: 0.1
        timeout: 120
        system_prompt: 'You are a test design expert. Think step by step.'
      testcase:
        model: 'google/gemini-3-flash-preview'
        api_url: 'https://openrouter.ai/api/v1/chat/completions'
        temperature: 0.1
        timeout: 120
        system_prompt: 'You are a QA engineer writing detailed test cases.'
      audit:
        model: 'google/gemini-3-flash-preview'
        api_url: 'https://openrouter.ai/api/v1/chat/completions'
        temperature: 0.1
        timeout: 120
        system_prompt: 'You are a QA reviewer auditing generated test cases.'
    prompts:
      requirement_ir: |-
        你是需求結構化引擎。請使用 {review_language}，把 Jira ticket 轉成 machine-readable requirement IR。

        TCG: {ticket_key}
        Summary: {ticket_summary}
        Description:
        {ticket_description}
        Components: {ticket_components}

        你必須只輸出「單一 JSON 物件」，不可有 Markdown/code fence/說明文字。
        不可杜撰需求，只能抽取、重組、標準化。若資訊不足可留空字串或空陣列，不可腦補。
        必須完整保留 ticket 的需求訊息（包含 AC、規則、例外、表格欄位語義、多語內容）。
        若原文有表格/欄位定義，必須逐欄展開到 reference_columns，不可用範圍字串取代。
        若輸出長度接近上限，優先精簡句子長度，不可刪除條目；不可輸出截斷 JSON。

        Schema:
        {
          "ticket":{"key":"TCG-123","summary":"...","components":["Auth"]},
          "scenarios":[
            {"rid":"REQ-001","g":"功能群組","t":"需求標題","ac":["可驗證條件"],"rules":["業務規則"],"data_points":["欄位/條件"],"expected":["預期"],"trace":{"source":"description","snippet":"..."}}
          ],
          "reference_columns":[
            {"rid":"REF-001","column":"欄位名稱","new_column":false,"sortable":true,"fixed_lr":"left","format_rules":["規則"],"cross_page_param":"param","edit_note":"註記","expected":["此欄位可觀察結果"],"trace":{"source":"reference_table","row":"1"}}
          ],
          "notes":["補充說明"]
        }
      analysis: |-
        你是 Analysis+Coverage 合併轉換器。請使用 {review_language}，根據 requirement IR 一次輸出 analysis 與 coverage。

        TCG: {ticket_key}
        Requirement IR JSON:
        {requirement_ir_json}

        只輸出單一 JSON 物件，不可有 Markdown/code fence/說明文字。
        規則：
        - 本階段是單一 prompt，必須直接完成可用於 pre-testcase 的 analysis+coverage。
        - analysis:
          - 先按功能分 section（g），每個 section 內提供 it。
          - 每個 item 都是「可執行的驗證條目」，不可只寫 REF 代號或模糊描述。
          - item.id 必須為可追蹤格式（例如 010.001），供 coverage 的 ref 使用。
          - 若同一驗證條目同時驗 4 個欄位（如名字/生日/電話/地址排序），可放同一 item，但 item.chk 必須明列 4 個欄位與驗證動作；item.exp 必須明列對應預期。
          - item.t 需具體可操作；item.det 只放邊界/限制補充。
          - 每個 item 必須帶 rid；rid 中 REF 禁止區間寫法（例如 REF-001~REF-018）。
          - 若 requirement_ir.reference_columns 有 N 個欄位，analysis 需至少覆蓋 N 個欄位語義（可一對一或在同條 item 逐欄列明）。
        - coverage:
          - 每個 seed 對應 1 個未來 test case（1 seed = 1 expected result）。
          - 每個 seed.ref 必須且只能有 1 個 analysis item.id。
          - coverage 必須明確考慮四個面向：happy path、edge test cases、error handling、permission。
          - seed.ax 僅允許：happy、edge、error、permission。
          - seed.cat 必須遵守映射：happy->happy，edge->boundary，error/permission->negative。
          - 若某面向不適用，仍需輸出對應 seed，並設定 st=assume 且在 a 提供原因。
          - 每個 seed 必須提供 t、chk、exp、pre_hint、step_hint。
          - 輸出 sec（分組）與 seed（展平）兩種視圖。
          - 完整性契約：
            1) Analysis 每個 item.id 至少出現在一個 seed.ref
            2) Analysis 每個 section.g 必須出現在 coverage.sec[].g
            3) trace 需回報 analysis_item_count、covered_item_count、missing_ids、missing_sections
        - 若內容長，優先精簡措辭，不可省略條目，不可輸出截斷 JSON。
        Schema:
        {
          "analysis":{
            "sec":[
              {"g":"功能名稱","it":[{"id":"010.001","t":"驗證排序欄位顯示與排序行為","det":["限制條件"],"chk":["姓名欄位可排序","生日欄位可排序","電話欄位可排序","地址欄位可排序"],"exp":["姓名依升冪排列","生日依升冪排列","電話依升冪排列","地址依升冪排列"],"rid":["REQ-001","REF-001"]}]}
            ],
            "it":[{"id":"010.001","t":"...","det":["..."],"chk":["..."],"exp":["..."],"rid":["REQ-001"]}]
          },
          "coverage":{
            "sec":[{"g":"功能名稱","seed":[{"g":"功能名稱","t":"驗證欄位排序","ax":"happy","cat":"happy","st":"ok","a":"","ref":["010.001"],"rid":["REQ-001","REF-001"],"chk":["姓名可排序","生日可排序"],"exp":["姓名升冪","生日升冪"],"pre_hint":["已有多筆資料"],"step_hint":["點擊欄位標題觸發排序"]}]}],
            "seed":[{"g":"功能名稱","t":"...","ax":"happy","cat":"happy","st":"ok","a":"","ref":["010.001"],"rid":["REQ-001"],"chk":["..."],"exp":["..."],"pre_hint":["..."],"step_hint":["..."]}],
            "trace":{"analysis_item_count":0,"covered_item_count":0,"missing_ids":[],"missing_sections":[],"aspect_review":{"happy":"covered","edge":"covered","error":"covered","permission":"assume"}}
          }
        }
      coverage: |-
        你是 QA 測試設計師。請使用 {review_language}，根據 Requirement IR + Analysis 產生 pre-testcase seeds。

        Requirement IR JSON:
        {requirement_ir_json}
        Analysis JSON:
        {expanded_requirements_json}

        只輸出單一 JSON 物件，不可有 Markdown/code fence/說明文字。
        輸出必須可直接被 JSON.parse 成功。
        規則：
        - 每個 seed 對應 1 個未來 test case（1 seed = 1 expected result）。
        - seed.ref 必須且只能有 1 個 analysis item.id。
        - coverage 類別僅允許：happy、negative、boundary。
        - 每個 seed 必須提供足夠線索給低推理模型：t、chk、exp、pre_hint、step_hint。
        - seed.t 不可只寫「參考 REF-xxx」；必須描述可執行檢核。
        - 若 seed 涵蓋多欄位，chk/exp 必須逐欄列明。
        - rid 若含 REF，僅允許單一 REF token，禁止 REF 區間。
        - 輸出 sec（分組）與 seed（展平）兩種視圖。
        - 完整性契約：
          1) Analysis 每個 item.id 必須至少出現在一個 seed.ref
          2) Analysis 每個 section.g 必須出現在 coverage.sec[].g
          3) 輸出 trace 統計：analysis_item_count、covered_item_count、missing_ids、missing_sections
        - 若內容太長，優先縮短文字，不可刪條目，不可輸出截斷 JSON。
        Schema:
        {
          "sec":[{"g":"功能名稱","seed":[{"g":"功能名稱","t":"驗證欄位排序","cat":"happy","st":"ok","ref":["010.001"],"rid":["REQ-001","REF-001"],"chk":["姓名可排序","生日可排序"],"exp":["姓名升冪","生日升冪"],"pre_hint":["已有多筆資料"],"step_hint":["點擊欄位標題觸發排序"]}]}],
          "seed":[{"g":"功能名稱","t":"...","cat":"happy","st":"ok","ref":["010.001"],"rid":["REQ-001"],"chk":["..."],"exp":["..."],"pre_hint":["..."],"step_hint":["..."]}],
          "trace":{"analysis_item_count":0,"covered_item_count":0,"missing_ids":[],"missing_sections":[]}
        }
      coverage_backfill: |-
        你是 QA 覆蓋補全器。請使用 {review_language}，只補 missing_ids/missing_sections，不可改寫既有 coverage。

        Requirement IR JSON:
        {requirement_ir_json}
        Analysis JSON:
        {expanded_requirements_json}
        Current Coverage JSON:
        {current_coverage_json}
        Missing analysis ids:
        {missing_ids_json}
        Missing sections:
        {missing_sections_json}

        只輸出單一 JSON 物件，不可有 Markdown/code fence/說明文字。
        規則：
        - 只新增 seed，不可覆寫既有 seed。
        - 每個新增 seed.ref 必須且只能有 1 個 item.id。
        - 每個新增 seed 仍需提供 t/chk/exp/pre_hint/step_hint 線索。
        - rid 若含 REF，僅允許單一 REF token，禁止區間。
        - 若字數過長，縮短句子，不可輸出截斷 JSON。
        Schema:
        {"seed":[{"g":"功能名稱","t":"...","cat":"happy","st":"ok","ref":["010.001"],"rid":["REQ-001"],"chk":["..."],"exp":["..."],"pre_hint":["..."],"step_hint":["..."]}],"trace":{"resolved_ids":["010.001"],"resolved_sections":["功能名稱"]}}
      testcase: |-
        你是 QA 工程師。請使用 {output_language}，根據單一 section 的 pre-testcase 條目產生詳細 test cases。

        TCG: {ticket_key}
        Section: {section_no} {section_name}
        Stage 1 Entries JSON (single section):
        {coverage_questions_json}
        Retrieved clues (jira_references + test_cases):
        {similar_cases}
        Retry hint:
        {retry_hint}

        只輸出單一 JSON 物件，不可有 Markdown/code fence/說明文字。
        規則：
        - 只處理輸入 section 的 en 條目。
        - 每個 en 條目必須且只能產生一筆 testcase（1:1）。
        - testcase.id 必須是 {ticket_key}.{en.cid}。
        - t 必須具體，且能反映 chk/exp 線索，不可空泛。
        - pre 至少 2 條，且需包含測試資料與角色/權限或入口條件。
        - s 至少 3 步，且每一步都必須可操作、可重現。
        - exp 必須且只能有 1 筆字串，且需包含可觀測結果（畫面元素/回傳欄位/狀態碼/訊息）。
        - st=assume 時，t 需以 [ASSUME] 開頭，並在 pre 或 exp 明示假設。
        - st=ask 時，t 需以 [TBD] 開頭，並在 pre 或 exp 明示「待確認事項」（不可使用 TBD/N/A/同上/略）。
        - pre/s/exp 禁止出現 REF/同上/略/TBD/N/A 這類占位詞。
        - 不可遺漏條目；不可輸出截斷 JSON。
        Schema:
        {"tc":[{"id":"{ticket_key}.010.010","t":"...","pre":["詳細前置條件"],"s":["詳細步驟1","詳細步驟2"],"exp":["單一且完整的預期結果"]}]}
      testcase_supplement: |-
        你是 QA 補全器。請使用 {output_language}，只補上缺漏或不合格的 testcases。

        TCG: {ticket_key}
        Section: {section_no} {section_name}
        Missing/Invalid Stage 1 Entries JSON:
        {coverage_questions_json}
        Current testcase JSON:
        {testcase_json}
        Retrieved clues (jira_references + test_cases):
        {similar_cases}
        Retry hint:
        {retry_hint}

        只輸出單一 JSON 物件，不可有 Markdown/code fence/說明文字。
        規則：
        - 只輸出需要補全的 testcase；不要重複輸出已正確條目。
        - id 必須使用 {ticket_key}.{en.cid}。
        - pre 至少 2 條、s 至少 3 步；exp 必須且只能 1 筆且可觀測。
        - pre/s/exp 禁止出現 REF/同上/略/TBD/N/A 這類占位詞。
        - 不可輸出截斷 JSON。
        Schema:
        {"tc":[{"id":"{ticket_key}.010.020","t":"...","pre":["..."],"s":["..."],"exp":["..."]}]}
      audit: |-
        你是 QA 審查員。請使用 {output_language}，審查並補強單一 section 的 testcases。

        TCG: {ticket_key}
        Section: {section_no} {section_name}
        Stage 1 Entries JSON (single section):
        {coverage_questions_json}
        Testcases JSON:
        {testcase_json}
        Retrieved clues (jira_references + test_cases):
        {similar_cases}
        Retry hint:
        {retry_hint}

        只輸出單一 JSON 物件，不可有 Markdown/code fence/說明文字。
        規則：
        - 保持每筆 id 不變；若缺項可補全內容，但不可變更目標條目集合。
        - 必須逐條對照 en 的 chk/exp 線索補強 pre/s/exp 細節。
        - pre 至少 2 條、s 至少 3 步；exp 必須且只能有 1 筆（單一核心預期且可觀測）。
        - [ASSUME]/[TBD] 規則必須正確，且 pre/s/exp 禁止使用 REF/同上/略/TBD/N/A。
        - 不可遺漏條目；不可輸出截斷 JSON。
        Schema:
        {"tc":[{"id":"{ticket_key}.010.010","t":"...","pre":["..."],"s":["..."],"exp":["..."]}]}
qdrant:
  url: 'http://localhost:6333'
  api_key: ''
  timeout: 30
  prefer_grpc: false
  pool_size: 32
  max_concurrent_requests: 32
  max_retries: 3
  retry_backoff_seconds: 0.5
  retry_backoff_max_seconds: 5.0
  check_compatibility: true
  collection_jira_referances: 'jira_references'
  collection_test_cases: 'test_cases'
  collection_usm_nodes: 'usm_nodes'
  weights:
    test_cases: 0.7
    usm_nodes: 0.3
  limit:
    jira_referances: 20
    test_cases: 14
    usm_nodes: 6
auth:
  enable_auth: true
  jwt_secret_key: '${JWT_SECRET_KEY}'  # 必須由環境變數提供
  jwt_expire_days: 7
  password_reset_expire_hours: 24
  session_cleanup_days: 30
audit:
  enabled: true
  database_url: 'sqlite:///./audit.db'
  batch_size: 100
  cleanup_days: 365
  max_detail_size: 10240
  excluded_fields: ['password', 'token', 'secret', 'key']
  debug_sql: false
attachments:
  root_dir: ''  # 留空使用專案內 attachments 目錄
